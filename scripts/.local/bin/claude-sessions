#!/bin/bash
# Claude Code Session Picker
# Browse by workspace first, then by session within that workspace

PROJECTS_DIR="$HOME/.claude/projects"
declare -A CUSTOM_TITLES  # Cache for custom session titles

if [[ ! -d "$PROJECTS_DIR" ]]; then
    notify-send "Claude Sessions" "No sessions found"
    exit 1
fi

# Helper function to extract session summary
# Priority: 1) custom-title (from cache), 2) summary line, 3) first user message
get_session_summary() {
    local file="$1"
    local session_id="$2"
    local summary

    # 1. Check for custom-title from pre-built cache (set by caller)
    if [[ -n "$session_id" && -n "${CUSTOM_TITLES[$session_id]:-}" ]]; then
        echo "${CUSTOM_TITLES[$session_id]}"
        return
    fi

    # 2. Try to find a dedicated summary line
    summary=$(grep -m1 '"type"[[:space:]]*:[[:space:]]*"summary"' "$file" 2>/dev/null | jq -r '.summary // ""' 2>/dev/null)

    if [[ -n "$summary" && "$summary" != "null" ]]; then
        echo "$summary"
        return
    fi

    # 3. Fallback: get first user message content (truncated)
    # Content can be a string OR an array of {type,text} objects
    local user_line
    user_line=$(grep -m1 '"type"[[:space:]]*:[[:space:]]*"user"' "$file" 2>/dev/null)

    if [[ -n "$user_line" ]]; then
        local content_type
        content_type=$(echo "$user_line" | jq -r '.message.content | type' 2>/dev/null)

        if [[ "$content_type" == "string" ]]; then
            summary=$(echo "$user_line" | jq -r '.message.content // ""' 2>/dev/null)
        elif [[ "$content_type" == "array" ]]; then
            # Extract text from first content block
            summary=$(echo "$user_line" | jq -r '.message.content[0].text // ""' 2>/dev/null)
        fi

        # Filter out internal/system messages
        if [[ -n "$summary" && "$summary" != "null" ]]; then
            # Skip if starts with common internal patterns
            if [[ "$summary" =~ ^(\<command-|\<system-|caveat:|CAVEAT:) ]]; then
                summary=""
            else
                # Truncate to 80 chars
                summary=$(echo "$summary" | head -c 80)
                if [[ ${#summary} -ge 80 ]]; then
                    summary="${summary}..."
                fi
                echo "$summary"
                return
            fi
        fi
    fi

    echo ""
}

# Build custom title cache for a project directory (call once per workspace)
build_custom_title_cache() {
    local project_dir="$1"
    CUSTOM_TITLES=()

    local titles_json
    titles_json=$(grep -h '"type"[[:space:]]*:[[:space:]]*"custom-title"' "$project_dir"/*.jsonl 2>/dev/null || true)

    if [[ -n "$titles_json" ]]; then
        while IFS= read -r line; do
            local sid title
            sid=$(echo "$line" | jq -r '.sessionId // ""' 2>/dev/null)
            title=$(echo "$line" | jq -r '.customTitle // ""' 2>/dev/null)
            if [[ -n "$sid" && -n "$title" && "$title" != "null" ]]; then
                CUSTOM_TITLES["$sid"]="$title"
            fi
        done <<< "$titles_json"
    fi
}

# Helper function to count actual conversation messages
count_messages() {
    local file="$1"
    local count
    # Count lines with type "user" or type "assistant"
    # Note: grep -c returns 0 with exit code 1 when no matches, so we capture and default
    count=$(grep -c '"type"[[:space:]]*:[[:space:]]*"\(user\|assistant\)"' "$file" 2>/dev/null) || true
    echo "${count:-0}"
}

# Build workspace list
workspace_list=""
for project_dir in "$PROJECTS_DIR"/*/; do
    [[ ! -d "$project_dir" ]] && continue

    project_name=$(basename "$project_dir")
    # Convert dashes back to slashes, but we need to find the actual path
    # since the conversion is lossy (both / and - become - in storage)
    project_path="${project_name//-//}"

    # Try to find the actual existing path by checking filesystem
    # Start with full slash conversion, then try preserving dashes progressively
    if [[ ! -d "$project_path" ]]; then
        # The naive conversion failed, try to find actual path
        # by reading the cwd from a session file
        for session_file in "$project_dir"/*.jsonl; do
            [[ ! -f "$session_file" ]] && continue
            actual_cwd=$(grep -m1 '"cwd"' "$session_file" 2>/dev/null | jq -r '.cwd // ""' 2>/dev/null)
            if [[ -n "$actual_cwd" && -d "$actual_cwd" ]]; then
                project_path="$actual_cwd"
                break
            fi
        done
    fi

    # Count valid sessions (fast: just check for messages, skip summary extraction)
    count=0
    latest_mtime=0
    for file in "$project_dir"/*.jsonl; do
        [[ ! -f "$file" ]] && continue
        [[ $(stat -c %s "$file") -eq 0 ]] && continue

        session_id=$(basename "$file" .jsonl)
        [[ "$session_id" == agent-* ]] && continue

        # Quick check: has at least one user/assistant message?
        grep -q '"type"[[:space:]]*:[[:space:]]*"\(user\|assistant\)"' "$file" 2>/dev/null || continue

        ((count++)) || true
        mtime=$(stat -c %Y "$file" 2>/dev/null || echo "0")
        [[ $mtime -gt $latest_mtime ]] && latest_mtime=$mtime
    done

    [[ $count -eq 0 ]] && continue

    short_path=$(echo "$project_path" | sed 's|/home/cwar|~|')
    workspace_list+="${latest_mtime}|${short_path} (${count} sessions)|${project_path}"$'\n'
done

if [[ -z "$workspace_list" ]]; then
    notify-send "Claude Sessions" "No sessions found"
    exit 1
fi

# Sort by mtime and show workspace picker
sorted_ws=$(echo -n "$workspace_list" | sort -t'|' -k1 -rn)
ws_display=$(echo "$sorted_ws" | cut -d'|' -f2)

# Use -format i to get line number (0-based), not text
selected_ws_idx=$(echo "$ws_display" | rofi -dmenu -i -p "Select Workspace" -format i -theme-str 'window {width: 50%;}')

[[ -z "$selected_ws_idx" ]] && exit 0

# Get project path by line number
project_path=$(echo "$sorted_ws" | sed -n "$((selected_ws_idx + 1))p" | cut -d'|' -f3)
project_dir="$PROJECTS_DIR/${project_path//\//-}"

# Helper function for relative time
time_ago() {
    local seconds=$1
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds} seconds ago"
    elif [[ $seconds -lt 3600 ]]; then
        echo "$((seconds / 60)) minutes ago"
    elif [[ $seconds -lt 86400 ]]; then
        echo "$((seconds / 3600)) hours ago"
    elif [[ $seconds -lt 604800 ]]; then
        echo "$((seconds / 86400)) days ago"
    else
        echo "$((seconds / 604800)) weeks ago"
    fi
}

# Get sessions for selected workspace
session_list=""
now=$(date +%s)
build_custom_title_cache "$project_dir"  # Rebuild cache for this workspace
for file in "$project_dir"/*.jsonl; do
    [[ ! -f "$file" ]] && continue
    [[ $(stat -c %s "$file") -eq 0 ]] && continue

    session_id=$(basename "$file" .jsonl)
    [[ "$session_id" == agent-* ]] && continue

    summary=$(get_session_summary "$file" "$session_id")
    [[ -z "$summary" ]] && continue

    # Sanitize pipe chars to avoid delimiter collision
    summary="${summary//|/-}"

    # Count actual user/assistant messages - skip empty sessions
    msg_count=$(count_messages "$file")
    [[ "$msg_count" -eq 0 ]] && continue

    mtime=$(stat -c %Y "$file" 2>/dev/null || echo "0")
    age=$((now - mtime))
    time_str=$(time_ago $age)

    session_list+="${mtime}|${summary} - ${time_str} - ${msg_count} msgs|${session_id}"$'\n'
done

if [[ -z "$session_list" ]]; then
    notify-send "Claude Sessions" "No sessions in this workspace"
    exit 1
fi

# Sort and show session picker
sorted_sessions=$(echo -n "$session_list" | sort -t'|' -k1 -rn)
session_display=$(echo "$sorted_sessions" | cut -d'|' -f2)

# Use -format i to get line number (0-based), not text - avoids matching bugs
selected_idx=$(echo "$session_display" | rofi -dmenu -i -p "Select Session" -format i -theme-str 'window {width: 60%;}')

[[ -z "$selected_idx" ]] && exit 0

# Get session ID by line number (add 1 since sed uses 1-based indexing)
session_id=$(echo "$sorted_sessions" | sed -n "$((selected_idx + 1))p" | cut -d'|' -f3)

# DEBUG: Show what was selected
notify-send "DEBUG" "idx=$selected_idx, session_id=$session_id"
echo "=== DEBUG ===" >> /tmp/claude-sessions-debug.log
echo "selected_idx: $selected_idx" >> /tmp/claude-sessions-debug.log
echo "sorted_sessions (first 10):" >> /tmp/claude-sessions-debug.log
echo "$sorted_sessions" | head -10 >> /tmp/claude-sessions-debug.log
echo "selected line: $(echo "$sorted_sessions" | sed -n "$((selected_idx + 1))p")" >> /tmp/claude-sessions-debug.log
echo "session_id: $session_id" >> /tmp/claude-sessions-debug.log
echo "project_path: $project_path" >> /tmp/claude-sessions-debug.log
echo "==============" >> /tmp/claude-sessions-debug.log

if [[ -z "$session_id" ]]; then
    notify-send "Claude Sessions" "Could not find session"
    exit 1
fi

# Launch terminal with claude in tmux
exec ghostty --working-directory="$project_path" -e bash -lic "tmux new-session -A -s claude 'claude --resume \"$session_id\"'"
