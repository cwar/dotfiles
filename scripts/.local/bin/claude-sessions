#!/bin/bash
# Claude Code Session Picker
# Browse by workspace first, then by session within that workspace

PROJECTS_DIR="$HOME/.claude/projects"

if [[ ! -d "$PROJECTS_DIR" ]]; then
    notify-send "Claude Sessions" "No sessions found"
    exit 1
fi

# Helper function to extract session summary
# Priority: 1) custom-title, 2) summary line, 3) first user message
get_session_summary() {
    local file="$1"
    local session_id="$2"
    local project_dir="$3"
    local summary

    # 1. Check for custom-title (user-renamed session)
    if [[ -n "$session_id" && -n "$project_dir" ]]; then
        summary=$(grep -h '"type"[[:space:]]*:[[:space:]]*"custom-title"' "$project_dir"/*.jsonl 2>/dev/null | \
            jq -r --arg sid "$session_id" 'select(.sessionId == $sid) | .customTitle // ""' 2>/dev/null | head -1)
        if [[ -n "$summary" && "$summary" != "null" ]]; then
            echo "$summary"
            return
        fi
    fi

    # 2. Try to find a dedicated summary line
    summary=$(grep -m1 '"type"[[:space:]]*:[[:space:]]*"summary"' "$file" 2>/dev/null | jq -r '.summary // ""' 2>/dev/null)

    if [[ -n "$summary" && "$summary" != "null" ]]; then
        echo "$summary"
        return
    fi

    # 3. Fallback: get first user message content (truncated)
    # Content can be a string OR an array of {type,text} objects
    local user_line
    user_line=$(grep -m1 '"type"[[:space:]]*:[[:space:]]*"user"' "$file" 2>/dev/null)

    if [[ -n "$user_line" ]]; then
        local content_type
        content_type=$(echo "$user_line" | jq -r '.message.content | type' 2>/dev/null)

        if [[ "$content_type" == "string" ]]; then
            summary=$(echo "$user_line" | jq -r '.message.content // ""' 2>/dev/null)
        elif [[ "$content_type" == "array" ]]; then
            # Extract text from first content block
            summary=$(echo "$user_line" | jq -r '.message.content[0].text // ""' 2>/dev/null)
        fi

        # Filter out internal/system messages
        if [[ -n "$summary" && "$summary" != "null" ]]; then
            # Skip if starts with common internal patterns
            if [[ "$summary" =~ ^(\<command-|\<system-|caveat:|CAVEAT:) ]]; then
                summary=""
            else
                # Truncate to 80 chars
                summary=$(echo "$summary" | head -c 80)
                if [[ ${#summary} -ge 80 ]]; then
                    summary="${summary}..."
                fi
                echo "$summary"
                return
            fi
        fi
    fi

    echo ""
}

# Helper function to count actual conversation messages
count_messages() {
    local file="$1"
    local count
    # Count lines with type "user" or type "assistant"
    # Note: grep -c returns 0 with exit code 1 when no matches, so we capture and default
    count=$(grep -c '"type"[[:space:]]*:[[:space:]]*"\(user\|assistant\)"' "$file" 2>/dev/null) || true
    echo "${count:-0}"
}

# Build workspace list
workspace_list=""
for project_dir in "$PROJECTS_DIR"/*/; do
    [[ ! -d "$project_dir" ]] && continue

    project_name=$(basename "$project_dir")
    # Convert dashes back to slashes, but we need to find the actual path
    # since the conversion is lossy (both / and - become - in storage)
    project_path="${project_name//-//}"

    # Try to find the actual existing path by checking filesystem
    # Start with full slash conversion, then try preserving dashes progressively
    if [[ ! -d "$project_path" ]]; then
        # The naive conversion failed, try to find actual path
        # by reading the cwd from a session file
        for session_file in "$project_dir"/*.jsonl; do
            [[ ! -f "$session_file" ]] && continue
            actual_cwd=$(grep -m1 '"cwd"' "$session_file" 2>/dev/null | jq -r '.cwd // ""' 2>/dev/null)
            if [[ -n "$actual_cwd" && -d "$actual_cwd" ]]; then
                project_path="$actual_cwd"
                break
            fi
        done
    fi

    # Count valid sessions
    count=0
    latest_mtime=0
    for file in "$project_dir"/*.jsonl; do
        [[ ! -f "$file" ]] && continue
        [[ $(stat -c %s "$file") -eq 0 ]] && continue

        session_id=$(basename "$file" .jsonl)
        [[ "$session_id" == agent-* ]] && continue

        summary=$(get_session_summary "$file" "$session_id" "$project_dir")
        [[ -z "$summary" ]] && continue

        # Skip sessions with no messages
        msg_count=$(count_messages "$file")
        [[ "$msg_count" -eq 0 ]] && continue

        ((count++)) || true
        mtime=$(stat -c %Y "$file" 2>/dev/null || echo "0")
        [[ $mtime -gt $latest_mtime ]] && latest_mtime=$mtime
    done

    [[ $count -eq 0 ]] && continue

    short_path=$(echo "$project_path" | sed 's|/home/cwar|~|')
    workspace_list+="${latest_mtime}|${short_path} (${count} sessions)|${project_path}"$'\n'
done

if [[ -z "$workspace_list" ]]; then
    notify-send "Claude Sessions" "No sessions found"
    exit 1
fi

# Sort by mtime and show workspace picker
sorted_ws=$(echo -n "$workspace_list" | sort -t'|' -k1 -rn)
ws_display=$(echo "$sorted_ws" | cut -d'|' -f2)

selected_ws=$(echo "$ws_display" | rofi -dmenu -i -p "Select Workspace" -theme-str 'window {width: 50%;}')

[[ -z "$selected_ws" ]] && exit 0

# Find the matching project path (exact field match)
project_path=$(echo "$sorted_ws" | awk -F'|' -v sel="$selected_ws" '$2 == sel {print $3; exit}')
project_dir="$PROJECTS_DIR/${project_path//\//-}"

# Helper function for relative time
time_ago() {
    local seconds=$1
    if [[ $seconds -lt 60 ]]; then
        echo "${seconds} seconds ago"
    elif [[ $seconds -lt 3600 ]]; then
        echo "$((seconds / 60)) minutes ago"
    elif [[ $seconds -lt 86400 ]]; then
        echo "$((seconds / 3600)) hours ago"
    elif [[ $seconds -lt 604800 ]]; then
        echo "$((seconds / 86400)) days ago"
    else
        echo "$((seconds / 604800)) weeks ago"
    fi
}

# Get sessions for selected workspace
session_list=""
now=$(date +%s)
for file in "$project_dir"/*.jsonl; do
    [[ ! -f "$file" ]] && continue
    [[ $(stat -c %s "$file") -eq 0 ]] && continue

    session_id=$(basename "$file" .jsonl)
    [[ "$session_id" == agent-* ]] && continue

    summary=$(get_session_summary "$file" "$session_id" "$project_dir")
    [[ -z "$summary" ]] && continue

    # Count actual user/assistant messages - skip empty sessions
    msg_count=$(count_messages "$file")
    [[ "$msg_count" -eq 0 ]] && continue

    mtime=$(stat -c %Y "$file" 2>/dev/null || echo "0")
    age=$((now - mtime))
    time_str=$(time_ago $age)

    session_list+="${mtime}|${summary} - ${time_str} - ${msg_count} msgs|${session_id}"$'\n'
done

if [[ -z "$session_list" ]]; then
    notify-send "Claude Sessions" "No sessions in this workspace"
    exit 1
fi

# Sort and show session picker
sorted_sessions=$(echo -n "$session_list" | sort -t'|' -k1 -rn)
session_display=$(echo "$sorted_sessions" | cut -d'|' -f2)

selected_session=$(echo "$session_display" | rofi -dmenu -i -p "Select Session" -theme-str 'window {width: 60%;}')

[[ -z "$selected_session" ]] && exit 0

# Find matching session ID (exact field match)
session_id=$(echo "$sorted_sessions" | awk -F'|' -v sel="$selected_session" '$2 == sel {print $3; exit}')

if [[ -z "$session_id" ]]; then
    notify-send "Claude Sessions" "Could not find session"
    exit 1
fi

# Launch terminal with claude in tmux
exec ghostty --working-directory="$project_path" -e bash -lic "tmux new-session -A -s claude 'claude --resume \"$session_id\"'"
